use genai_types::{
    messages::{Role as GenaiRole, StopReason},
    CompletionRequest, CompletionResponse, Message, MessageContent, ToolChoice, Usage,
};
use mcp_protocol::tool::Tool as McpTool;
use serde::{Deserialize, Serialize};

/// Represents an error from the Gemini API
#[derive(Debug, Serialize, Deserialize)]
pub enum GeminiError {
    /// Invalid request format
    InvalidRequest(String),

    /// API error response
    ApiError { status: u16, message: String },

    /// HTTP error
    HttpError(String),

    /// Invalid response format
    InvalidResponse(String),

    /// JSON serialization/deserialization error
    SerdeError(String),

    /// Unsupported feature
    UnsupportedFeature(String),

    /// Serialization error
    SerializationError(String),
}

impl From<serde_json::Error> for GeminiError {
    fn from(err: serde_json::Error) -> Self {
        GeminiError::SerdeError(err.to_string())
    }
}

/// Role in a conversation (user or model)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Role {
    #[serde(rename = "user")]
    User,

    #[serde(rename = "model")]
    Model,

    #[serde(rename = "system")]
    System,
}

impl From<GenaiRole> for Role {
    fn from(role: GenaiRole) -> Self {
        match role {
            GenaiRole::User => Role::User,
            GenaiRole::Assistant => Role::Model,
            GenaiRole::System => Role::System,
        }
    }
}

impl From<Role> for GenaiRole {
    fn from(role: Role) -> Self {
        match role {
            Role::User => GenaiRole::User,
            Role::Model => GenaiRole::Assistant,
            Role::System => GenaiRole::System,
        }
    }
}

impl Default for Role {
    fn default() -> Self {
        Role::Model
    }
}

/// Represents inline media bytes.
/// The spec mentions needing an IANA MIME type when this is used.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Blob {
    /// The IANA MIME type of the media (e.g., "image/png", "application/pdf").
    pub mime_type: String,
    /// The raw byte data.
    #[serde(with = "serde_bytes")] // Use serde_bytes for efficient byte handling
    pub data: Vec<u8>,
}

/// Represents a predicted function call from the model.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionCall {
    /// The unique identifier for the function call.
    pub id: Option<String>,
    /// The name of the function to call (matching FunctionDeclaration.name).
    pub name: String,
    /// The arguments to pass to the function, represented as a JSON object.
    /// Using serde_json::Value allows for arbitrary JSON structures.
    /// Replace with a specific struct if the arguments structure is fixed.
    pub args: serde_json::Value,
    // Or, if args always has a known structure:
    // pub args: SpecificArgsStruct,
}

/// Represents the result output of a function call.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionResponse {
    pub id: Option<String>,
    /// The name of the function that was called (matching FunctionDeclaration.name).
    pub name: String,
    /// The output returned by the function, represented as a JSON object.
    pub response: serde_json::Value,
    // Or, if response always has a known structure:
    // pub response: SpecificResponseStruct,
}

/// Represents URI-based data.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FileData {
    /// The IANA MIME type of the file.
    pub mime_type: String,
    /// The URI pointing to the file data (e.g., "gs://bucket/object", "https://...")
    pub file_uri: String,
}

/// Represents code generated by the model intended for execution.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct ExecutableCode {
    /// The language of the code (e.g., "python", "javascript").
    pub language: String, // Consider using an enum if languages are fixed
    /// The code string.
    pub code: String,
}

/// Represents the result of executing ExecutableCode.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct CodeExecutionResult {
    /// The outcome of the execution (e.g., "SUCCESS", "ERROR").
    pub outcome: String, // Consider using an enum: enum Outcome { Success, Error }
    /// The output from the execution (e.g., stdout, stderr, or specific result).
    pub output: String,
    // Potentially add more structured fields depending on needs, e.g., exit_code: Option<i32>
}

// --- The main Part Data Enum (representing the Union type) ---

/// Represents the different types of data a Part can hold.
/// This corresponds to the union type described in the spec.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")] // Matches JSON keys like "text", "inlineData"
pub enum PartData {
    /// Inline text content.
    Text(String),
    /// Inline media bytes with MIME type.
    InlineData(Blob),
    /// A predicted function call.
    FunctionCall(FunctionCall),
    /// The result of a function call.
    FunctionResponse(FunctionResponse),
    /// URI-based file data.
    FileData(FileData),
    /// Code to be executed.
    ExecutableCode(ExecutableCode),
    /// Result of code execution.
    CodeExecutionResult(CodeExecutionResult),
}

// --- The Top-Level Part Struct ---

/// A datatype containing media that is part of a multi-part Content message.
/// Corresponds to the main 'Part' object in the spec.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Part {
    /// Optional. Indicates if the part is generated internally by the model
    /// as a step in its reasoning process ("thought").
    #[serde(skip_serializing_if = "Option::is_none")] // Omit from JSON if None
    pub thought: Option<bool>,

    /// The actual data content of the part. The `flatten` attribute ensures
    /// that the fields from the chosen `PartData` enum variant are directly
    /// included in the `Part` JSON object, matching the spec's representation
    /// (e.g., {"text": "hello"} instead of {"data": {"text": "hello"}}).
    #[serde(flatten)]
    pub data: PartData,
}

impl TryFrom<MessageContent> for Part {
    type Error = GeminiError;

    fn try_from(content: MessageContent) -> Result<Self, GeminiError> {
        match content {
            MessageContent::Text { text } => Ok(Part {
                thought: None,
                data: PartData::Text(text),
            }),
            MessageContent::ToolUse { name, input, id } => Ok(Part {
                thought: None,
                data: PartData::FunctionCall(FunctionCall {
                    id: Some(id),
                    name,
                    args: input,
                }),
            }),
            // This is hacky and I would be surprised if it worked. I need to update the tool use
            // to retain the name and I am not sure about the way we are serializing the
            // ToolContent to json, but this is what I am going with for now.
            MessageContent::ToolResult {
                tool_use_id,
                content,
                is_error: _,
            } => Ok(Part {
                thought: None,
                data: PartData::FunctionResponse(FunctionResponse {
                    id: Some(tool_use_id),
                    name: "none".to_string(),
                    response: serde_json::to_value(content[0].clone())
                        .map_err(|e| GeminiError::SerializationError(format!("{:?}", e)))?,
                }),
            }),
        }
    }
}

impl TryFrom<Part> for MessageContent {
    type Error = GeminiError;

    fn try_from(content: Part) -> Result<Self, GeminiError> {
        match content.data {
            PartData::Text(text) => Ok(MessageContent::Text { text }),
            PartData::FunctionCall(FunctionCall { id, name, args }) => {
                let id = id.unwrap_or_default();
                Ok(MessageContent::ToolUse {
                    id,
                    name,
                    input: args,
                })
            }
            PartData::FunctionResponse(FunctionResponse { id, name, response }) => {
                Ok(MessageContent::ToolResult {
                    tool_use_id: id.unwrap_or_default(),
                    content: vec![mcp_protocol::tool::ToolContent::Text {
                        text: serde_json::to_string(&response).unwrap_or_else(|_| "{}".to_string()),
                    }],
                    is_error: None,
                })
            }
            PartData::FileData(FileData {
                mime_type,
                file_uri,
            }) => Ok(MessageContent::Text {
                text: format!("[File content of type: {} at {}]", mime_type, file_uri),
            }),
            PartData::ExecutableCode(ExecutableCode { language, code }) => {
                Ok(MessageContent::Text {
                    text: format!("[Executable code in {}: {}]", language, code),
                })
            }
            PartData::CodeExecutionResult(CodeExecutionResult { outcome, output }) => {
                Ok(MessageContent::Text {
                    text: format!("[Code execution result: {} - {}]", outcome, output),
                })
            }
            PartData::InlineData(blob) => Ok(MessageContent::Text {
                text: format!("[Inline data of type: {}]", blob.mime_type),
            }),
        }
    }
}

/// Content from Gemini API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Content {
    pub parts: Vec<Part>,
    #[serde(default)]
    pub role: Role,
}

impl TryFrom<Message> for Content {
    type Error = GeminiError;
    fn try_from(message: Message) -> Result<Self, Self::Error> {
        Ok(Content {
            role: message.role.into(),
            parts: message
                .content
                .into_iter()
                .map(|part| {
                    part.try_into().map_err(|e| {
                        GeminiError::SerializationError(format!(
                            "Failed to convert message part: {:?}",
                            e
                        ))
                    })
                })
                .collect::<Result<Vec<Part>, GeminiError>>()
                .map_err(|e| GeminiError::SerializationError(format!("{:?}", e)))?,
        })
    }
}

impl TryFrom<Content> for Message {
    type Error = GeminiError;
    fn try_from(content: Content) -> Result<Self, Self::Error> {
        Ok(Message {
            role: content.role.into(),
            content: content
                .parts
                .into_iter()
                .map(|part| {
                    part.try_into().map_err(|e| {
                        GeminiError::SerializationError(format!(
                            "Failed to convert message part: {:?}",
                            e
                        ))
                    })
                })
                .collect::<Result<Vec<MessageContent>, GeminiError>>()
                .map_err(|e| GeminiError::SerializationError(format!("{:?}", e)))?,
        })
    }
}

/// Generation config for Gemini API
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct GenerationConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub temperature: Option<f32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_output_tokens: Option<u32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_p: Option<f32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub top_k: Option<u32>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub stop_sequences: Option<Vec<String>>,
}

/// Function declaration for Gemini tools
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionDeclaration {
    pub name: String,
    pub description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parameters: Option<serde_json::Value>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub response: Option<serde_json::Value>,
}

/// Tool type for Gemini API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Tool {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_declarations: Option<Vec<FunctionDeclaration>>,
}

impl TryFrom<McpTool> for FunctionDeclaration {
    type Error = GeminiError;

    fn try_from(tool: McpTool) -> Result<Self, Self::Error> {
        Ok(FunctionDeclaration {
            name: tool.name,
            description: tool.description.unwrap_or_default(),
            parameters: Some(tool.input_schema),
            response: None, // Response schema is not typically provided in MCP
        })
    }
}

impl TryFrom<FunctionDeclaration> for McpTool {
    type Error = GeminiError;

    fn try_from(decl: FunctionDeclaration) -> Result<Self, Self::Error> {
        Ok(McpTool {
            name: decl.name,
            description: Some(decl.description),
            input_schema: decl.parameters.unwrap_or(serde_json::json!({})),
            annotations: None,
        })
    }
}

/// Function calling mode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FunctionCallingMode {
    #[serde(rename = "AUTO")]
    Auto,
    #[serde(rename = "ANY")]
    Any,
    #[serde(rename = "NONE")]
    None,
}

/// Function calling configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCallingConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mode: Option<FunctionCallingMode>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_function_names: Option<Vec<String>>,
}

/// Tool configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ToolConfig {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub function_calling_config: Option<FunctionCallingConfig>,
}

/// Request to generate content
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GenerateContentRequest {
    pub model: String,

    pub contents: Vec<Content>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub generation_config: Option<GenerationConfig>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub system_instruction: Option<Content>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<Tool>>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_config: Option<ToolConfig>,
}

impl TryFrom<CompletionRequest> for GenerateContentRequest {
    type Error = GeminiError;
    fn try_from(request: CompletionRequest) -> Result<Self, Self::Error> {
        // Handle system instruction
        let system_instruction = if request.system.is_some() {
            Some(request.system.as_ref().map(|s| Content {
                role: Role::System,
                parts: vec![Part {
                    thought: None,
                    data: PartData::Text(s.clone()),
                }],
            }))
        } else {
            None
        };

        // Create generation config
        let generation_config = Some(GenerationConfig {
            temperature: request.temperature,
            max_output_tokens: Some(request.max_tokens),
            top_p: None,
            top_k: None,
            stop_sequences: None,
        });

        // Handle tools
        let tools = if let Some(tools) = request.tools {
            if !tools.is_empty() {
                let function_declarations = tools
                    .into_iter()
                    .map(|tool| tool.try_into())
                    .collect::<Result<Vec<FunctionDeclaration>, GeminiError>>()?;

                Some(vec![Tool {
                    function_declarations: Some(function_declarations),
                }])
            } else {
                None
            }
        } else {
            None
        };

        // Configure tool usage
        let tool_config = if tools.is_some() {
            let mode = match request.tool_choice {
                Some(ToolChoice::Auto) => FunctionCallingMode::Auto,
                Some(ToolChoice::Any) => FunctionCallingMode::Any,
                Some(ToolChoice::None) => FunctionCallingMode::None,
                Some(ToolChoice::Tool { .. }) => FunctionCallingMode::Any, // Specific tool = ANY mode
                None => FunctionCallingMode::Auto,                         // Default to auto
            };

            // If a specific tool was requested, set it in allowed_function_names
            let allowed_function_names = match &request.tool_choice {
                Some(ToolChoice::Tool { name }) => Some(vec![name.clone()]),
                _ => None,
            };

            Some(ToolConfig {
                function_calling_config: Some(FunctionCallingConfig {
                    mode: Some(mode),
                    allowed_function_names,
                }),
            })
        } else {
            None
        };

        Ok(GenerateContentRequest {
            model: request.model,
            contents: request
                .messages
                .into_iter()
                .map(|msg| msg.try_into())
                .collect::<Result<Vec<Content>, GeminiError>>()
                .map_err(|e| {
                    GeminiError::SerializationError(format!("Failed to convert message: {:?}", e))
                })?,
            generation_config,
            system_instruction: system_instruction.flatten(),
            tools,
            tool_config,
        })
    }
}

/// Usage metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UsageMetadata {
    pub prompt_token_count: u32,
    pub candidates_token_count: u32,
    pub total_token_count: u32,
}

impl TryFrom<UsageMetadata> for Usage {
    type Error = GeminiError;

    fn try_from(usage: UsageMetadata) -> Result<Self, Self::Error> {
        Ok(genai_types::Usage {
            input_tokens: usage.prompt_token_count,
            output_tokens: usage.candidates_token_count,
        })
    }
}

/// Candidate response from Gemini API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Candidate {
    pub content: Content,
    pub finish_reason: FinishReason,
    #[serde(default)]
    pub index: u32,
    #[serde(default)]
    pub safety_ratings: Vec<SafetyRating>,
}

/// Finish reason for the a candidate
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FinishReason {
    #[serde(rename = "FINISH_REASON_UNSPECIFIED")]
    FinishReasonUnspecified,

    #[serde(rename = "STOP")]
    Stop,

    #[serde(rename = "MAX_TOKENS")]
    MaxTokens,

    #[serde(rename = "SAFETY")]
    Safety,

    #[serde(rename = "RECITATION")]
    Recitation,

    #[serde(rename = "LANGUAGE")]
    Language,

    #[serde(rename = "OTHER")]
    Other,

    #[serde(rename = "BLOCKLIST")]
    Blocklist,

    #[serde(rename = "PROHIBITED_CONTENT")]
    ProhibitedContent,

    #[serde(rename = "SPII")]
    Spii,

    #[serde(rename = "MALFORMED_FUNCTION_CALL")]
    MalformedFunctionCall,

    #[serde(rename = "IMAGE_SAFETY")]
    ImageSafety,
}

impl From<FinishReason> for StopReason {
    fn from(reason: FinishReason) -> Self {
        match reason {
            FinishReason::FinishReasonUnspecified => StopReason::EndTurn,
            FinishReason::Stop => StopReason::EndTurn,
            FinishReason::MaxTokens => StopReason::MaxTokens,
            _ => StopReason::Other(
                serde_json::to_string(&reason).unwrap_or_else(|_| "Unknown".to_string()),
            ),
        }
    }
}

/// Safety rating from Gemini API
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyRating {
    pub category: String,
    pub probability: String,
}

/// Response from Gemini API
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct GenerateContentResponse {
    pub candidates: Option<Vec<Candidate>>,
    pub prompt_feedback: Option<PromptFeedback>,
    pub usage_metadata: Option<UsageMetadata>,
    pub model_version: String,
}

impl TryFrom<GenerateContentResponse> for CompletionResponse {
    type Error = GeminiError;

    fn try_from(response: GenerateContentResponse) -> Result<Self, Self::Error> {
        match response.candidates {
            Some(candidates) => {
                // We are only interested in the first candidate for now
                if candidates.is_empty() {
                    return Err(GeminiError::InvalidResponse(
                        "No candidates in response".to_string(),
                    ));
                }

                let candidate = candidates[0].clone();

                // Convert all parts in the candidate to MessageContent
                let content_parts = candidate
                    .content
                    .parts
                    .iter()
                    .map(|part| (*part).clone().try_into())
                    .collect::<Result<Vec<MessageContent>, GeminiError>>()?;

                let usage = match response.usage_metadata {
                    Some(usage) => Usage {
                        input_tokens: usage.prompt_token_count,
                        output_tokens: usage.candidates_token_count,
                    },
                    None => Usage {
                        input_tokens: 0,
                        output_tokens: 0,
                    },
                };

                // Check if the response contains a function call
                let has_function_call = content_parts
                    .iter()
                    .any(|part| matches!(part, MessageContent::ToolUse { .. }));

                // Set stop reason to ToolUse if function call is present
                let stop_reason = if has_function_call {
                    StopReason::ToolUse
                } else {
                    candidate.finish_reason.into()
                };

                Ok(CompletionResponse {
                    content: content_parts,
                    id: candidate.index.to_string(),
                    model: response.model_version,
                    role: candidate.content.role.into(),
                    stop_reason,
                    stop_sequence: None,
                    message_type: "gemini".to_string(),
                    usage,
                })
            }
            None => {
                return Err(GeminiError::InvalidResponse(format!(
                    "No candidates in response. Response: {:?}",
                    response
                )));
            }
        }
    }
}

/// Feedback on prompt
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PromptFeedback {
    pub safety_ratings: Vec<SafetyRating>,
}

/// Request type for the Google Proxy
#[derive(Debug, Serialize, Deserialize)]
pub enum GeminiRequest {
    GenerateContent {
        request: GenerateContentRequest,
        model: String,
        stream: bool,
    },
    ListModels,
}

/// Response from Google Proxy
#[derive(Debug, Serialize, Deserialize)]
pub enum GeminiResponse {
    Content { content: GenerateContentResponse },
    ListModels { models: Vec<ModelInfo> },
    Error { error: String },
}

/// Model information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelInfo {
    pub id: String,
    pub display_name: String,
    pub description: Option<String>,
    pub input_token_limit: u32,
    pub output_token_limit: u32,
    pub supported_generation_methods: Vec<String>,
    pub temperature_range: Option<(f32, f32)>,
    pub top_p_range: Option<(f32, f32)>,
    pub top_k_range: Option<(u32, u32)>,
}

impl From<ModelInfo> for genai_types::ModelInfo {
    fn from(model: ModelInfo) -> Self {
        genai_types::ModelInfo {
            id: model.id,
            display_name: model.display_name,
            provider: "google".to_string(),
            max_tokens: model.output_token_limit,
            pricing: None,
        }
    }
}

impl ModelInfo {
    pub fn get_default_models() -> Vec<ModelInfo> {
        vec![
            ModelInfo {
                id: "gemini-2.5-flash-preview-04-17".to_string(),
                display_name: "Gemini 2.5 Flash".to_string(),
                description: Some(
                    "Optimized for speed, versatile on a broad range of tasks".to_string(),
                ),
                input_token_limit: 1048576,
                output_token_limit: 65536,
                supported_generation_methods: vec![
                    "generateContent".to_string(),
                    "streamGenerateContent".to_string(),
                ],
                temperature_range: Some((0.0, 2.0)),
                top_p_range: Some((0.0, 1.0)),
                top_k_range: Some((1, 40)),
            },
            ModelInfo {
                id: "gemini-2.0-pro".to_string(),
                display_name: "Gemini 2.0 Pro".to_string(),
                description: Some(
                    "High-quality model with strong reasoning across a variety of tasks"
                        .to_string(),
                ),
                input_token_limit: 32_000,
                output_token_limit: 16_000,
                supported_generation_methods: vec![
                    "generateContent".to_string(),
                    "streamGenerateContent".to_string(),
                ],
                temperature_range: Some((0.0, 2.0)),
                top_p_range: Some((0.0, 1.0)),
                top_k_range: Some((1, 40)),
            },
        ]
    }
}
